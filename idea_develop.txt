root: automaton
children: List<Automaton>

transitions: list<transition> = empty
processed: hashmap<String> = empty
frontier: list<String> = empty

---------------------------------------------------------------------------------------
# data structs

automaton:
	# note - make immutable for JVM memory purposes
	init:string
	local_states:List<string>
	local_transitions:(Hashmap:string->transition)

transition:record
	source:state
	action_label:string
	target:state

state:record
	child:automaton
	child_local_state:string
	root_local_state:string
	munit:memory

memory:(Hashmap:automaton->string)


---------------------------------------------------------------------------------------
# the main algorithm

product_automaton:automaton

# transitions from the initial state
processed = [fresh_init]
frontier = []

zero_mem = []
for child in children:
    zero_mem[child] = child.init

for child in children:
    prod_init = (child, child.init, root.init, zero_mem)
    fresh_init.transitions.append(epsilon,prod_init)
    frontier.append(prod_init)

# build the product
while (frontier not empty):

    state = frontier.pop()

    child = get_child(state)
    child_local_state = get_child_state(state)
    root_local_state = get_root_state(state)
    curr_memory = get_memory(state)				

    processed.append(state)

    # process child's local transitions
    for transition in child.local_transitions[child_local_state]:
        result_state = (child, get_target(transition), root_local_state, curr_memory)
	state.transitions.append(get_action(transition), result_state)
	if result_state not in processed:
	   frontier.append(result_state)

    # process root's local transitions
    for transition in root.local_transitions[root_local_state]:
        result_state = (child, child_local_state, get_target(transition), curr_memory)
	state.transitions.append(get_action(transition), result_state)
	if result_state not in processed:
	   frontier.append(result_state)

    # process synchronised transitions of child and the root
    sync_transitions = get_joint_transitions(root, child, sync_labels)[state]

    for (sync_trans_child_proj, sync_trans_root_proj) in sync_transitions:

	curr_memory[child] = get_target(sync_trans_child_proj) 

	root_target = get_target(trans_root)
	for child in children:
	    result_state = (child, curr_memory[child], target, curr_memory)
	    state.transitions.append(get_action(trans_child), result)
	    if result not in processed:
	       frontier.append(result_state)
		
---------------------------------------------------------------------------------------
