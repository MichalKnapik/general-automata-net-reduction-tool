root: automaton
children: List<Automaton>

transitions: list<transition> = empty
processed: hashmap<String> = empty
frontier: list<String> = empty

---------------------------------------------------------------------------------------

# transitions from the initial state
processed = [fresh_init]

zero_mem = []
for child in children:
    zero_mem[child] = child.init

for child in children:
    prod_init = (child, child.init, root.init, zero_mem)
    frontier.append(prod_init)
    transitions.append((fresh_init, epsilon, prod_init))

# build the product
while (frontier not empty):

    state = frontier.pop()

    child = get_child(state)
    child_local_state = get_child_state(state)
    root_local_state = get_root_state(state)
    curr_memory = get_memory(state)				

    processed.append(state)
    
    for transition in child.local_transitions[child_local_state]:
        result_state = (child, get_target(transition), root_local_state, curr_memory)
	state.transitions.append(get_action(transition), result_state)
	if result_state not in processed:
	   frontier.append(result)

--- TODO BELOW ---


    for transition in root.local_transitions[state[child]]:
        result = (child(state), child_state(state), target(transition), memory(state))
	if result not in processed:
	   transitions.append((state, action(transition), result))
	   frontier.append(result)
	   
    for (trans_child, trans_root) in joint_transitions(root, child(state))[state]:
	new_memory = memory(state).copy
	new_memory[child] = target(trans_child)
	for child in children:
	        result = (child, memory[child], target(trans_root), new_memory)
		if result not in processed:
		   transitions.append((state, action(trans_child), result))
		   frontier.append(result)
		
---------------------------------------------------------------------------------------
